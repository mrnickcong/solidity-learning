# 基础语法

- [基础语法](#基础语法)
  - [数据类型](#数据类型)
    - [字符串类型](#字符串类型)

## 数据类型

solidity的数据结构主要包括：值类型、引用类型、映射类型等

其中：

值类型包括：

1. 布尔类型
2. 整数
3. 地址
4. 枚举

引用类型包括：

1. 数据存储位置
2. 数组
3. 数组切片
4. 结构体

### 字符串类型

Solidity语言对字符串的内置操作支持非常有限。

由于字符串是动态大小的数据类型，处理（拼接、切片、比较）他们通常比处理固定大小的数据类型更复杂和更昂贵。

例如：字符串的拼接需要创建一个新的动态数组来存储结果，这个过程涉及到内存分配和多次的复制操作，每一步都会消耗gas，在寸土寸金的以太坊网络，处理字符串是多么的昂贵。

优化建议：

1. 对于复杂的字符串操作，考虑在应用层（JS、golang、python层处理），而不是在智能合约层处理
2. 对于不需要永久存储在区块链上的数据，可以考虑使用memory、calldata类型存储，减少存储成本
3. 在智能合约中处理字符串可能会消耗更多的gas，特别是字符串作为参数或者需要存储在区块链上时

总的来说：solidity可以处理字符串，但是应该谨慎操作，避免不必要的高成本。


```solidity
// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.7.0 <0.9.0;

contract TestDemo {
    string a = "hello";
    string b = "world";

    string c = unicode"你好";

    function name() public view returns (string memory) {
        return c;
    }

    //字符串拼接
    function stringConcat() public view returns (string memory) {
        return string(abi.encodePacked(a, " ", b));
    }

    //字符串长度：计算ASCII码的长度
    function stringLength() public view returns (uint256) {
        return bytes(a).length;
    }

    //字符串相等
    function stringEquals() public view returns (bool) {
        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
    }
}


```